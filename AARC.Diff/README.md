# AARC.Diff
本项目为`.net10`类库用于生成aarc存档的“修改记录”

## aarc存档的特点
- 不超过1MB
- 是json对象字符串，`{...}`
- 根对象的属性分为两类：
  - 有主键的数组
    - 大量数据（占整个存档的90%～98%）
    - 每个元素必然是对象，且对象必然有一个正整数`id`属性，对象属性在5～20个左右
    - `id`属性在整个对象全局唯一，且可以确定是兼容int的正整数，以后不会升级
    - 不可能嵌套子级的“有主键的数组”
    - 每个属性较为简单（若有变化直接记录为整个属性替换，不深入每个属性）
  - 一般对象/普通数组
    - 少量数据（占整个存档的2%~10%）
- “有主键的数组”分为“关心顺序”和“不关心顺序”两类
  - 不关心：仅通过id辨别元素是否新增/移除/修改
  - 关心：如果长度/顺序变化，必须额外记录顺序变动
- “普通数组”分为“长数组”和“短数组”
  - 短：长度正好为2且元素均为decimal的数组，不记录内部改变，直接记录为整个数组替换
  - 长：每个元素都是对象，且必须通过某种方式判断“两个元素是否是同一个”，避免中间插入/移除造成后方元素大量替换
    - 每个对象较为简单，属性1～5个（若有变化记录为整个对象替换）

示例：
```json5
{
  "points": [ //"有主键数组"
    {"id": 1, "others": "value1"}, //除 id 外，其他属性可能是任何值
    {"id": 2, "others": "value2"}  //但必然有是数组且有 id
  ],
  "configs": { //一般对象
    "cfgType1": {}, //可能是任何值
    "cfgType2": {}
  }
}
```

## 本类库作用
### 设计目标
- 以“最节省存储空间”且“有一定可读性”为目标，记录json的变动
- 无需能“当作patch应用和撤销”
- 无状态缓存，无线程安全问题

### 提供
- 一个`DiffGenerator`静态类
- 上述静态类有一个`Diff`方法，参数包含新旧两个json字符串，以及一个options对象：
  - 哪些路径是“有主键的数组”
    - 对于“有主键的数组”，必须传入一个bool，表示是否关心其顺序
  - 哪些路径是“长普通数组”
    - 对于“长普通数组”，必须传入一个Func<JsonElement, string>
    - 上述Func的参数是数组元素，返回string类型的“equalityMark”，用于判断两个元素是否是同一个
    - 使用者应当确保“equalityMark”是稳定的，即“两个元素的equalityMark相同，那么这两个元素一定是同一个”
    - 使用者应当确保“equalityMark”是唯一的，即“两个元素的equalityMark不同，那么这两个元素一定是不同的”
- 上述方法：如果遇到又不是“短普通数组”（长度非2或元素不是decimal），又不是“长普通数组”，又不是“有主键的数组”，直接抛出异常
- 上述方法返回：一个用于记录变动的`System.Text.Json.Nodes.JsonNode`对象
  - 该对象的属性键为“path”，例如`points`，`configs/cfgType1`等
  - 如果键的path对应的值为“有主键的数组”，那么其值为：`{add:[], remove:[], replace:[], sequence:{old:[], new:[]}}`
    - add 数组：记录所有增加
      - `[{id: 1, ...(完整对象的其余属性)}, ...]`
    - remove 数组：记录所有移除
      - `[{id: 1, ...(完整对象的其余属性)}, ...]`
    - replace 数组：记录所有更换
      - `[{id: 1, old:{...(仅不同的属性)}, new:{...(仅不同的属性)}}, ...]`
    - sequence 对象：通过id数组记录顺序变更
      - 如果“不关心顺序”，则不出现该对象
      - 如果前后序列完全一致，也不出现该对象
      - 例子：`{old:[1,2,3], new:[1,3,2]}`
  - 如果键的path对应的值不是“有主键的数组”，那么其值为：`{old:..., new:...}`

## 实现思路
将json解析为`System.Text.Json.JsonDocument`来进行对比等操作，以获取最高性能